谈谈你对this的理解
第一：this的指向取决于函数的调用位置，和函数的声明位置位置没有关系。
第二：如何找出函数的调用位置？寻找调用栈 call stack。当前正在执行的函数的前一个调用。
第三：具体的表现形式：默认绑定，隐式绑定，显式绑定，new绑定，箭头函数。
第四：在优先级上 new绑定 > 显示绑定 > 隐式绑定 > 默认绑定

模块之间的独立性

模块的作用：方便地使用其它模块的代码，想要什么功能，就加载什么模块。

立即执行函数创建一个独立的作用域，和全局作用域隔离。
立即执行函数的外部无法访问到立即执行函数内部的变量。
封装私有变量，拒绝外部访问。
```
var module1 = (function() {
    var circle = {x: 0, y: 0, r: 1}

    function calculate(r) {
        return Math.PI * Math.pow(r, 2);
    }

    calculate(circle.r);
})();
```
```
var module2 = (function() {
    var rect = {w: 1, h: 1}

    function calculate(w, h) {
        return w * h;
    }

    calculate(rect.w, rect.h);
})();
```

Javascript模块规范
CommonJS规范 
AMD 规范
ES6 规范

客户端模块 - 异步加载 - AMD规范
服务端模块 - 同步加载 - Commomjs规范

Commomjs规范的require.js同步加载模块
这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，
可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，
这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，
可能要等很长时间，浏览器处于"假死"状态。
浏览器端的模块，不能采用同步加载，只能采用异步加载。

AMD规范的require.js异步加载模块
它采用异步方式加载模块，模块的加载不影响它后面语句的运行。
所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：
第一个参数[module]，是一个数组，里面的成员就是要加载的模块；
第二个参数callback，则是加载成功之后的回调函数。
